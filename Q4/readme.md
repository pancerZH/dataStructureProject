# 数据结构课程设计

#### 作者：张文喆

## N皇后问题

### 0. 项目简介  
八皇后问题是一个古老而著名的问题，是回溯算法的经典问题。  
该问题是十九世纪著名的数学家高斯在 1850 年提出的：在 8*8 的国际象棋棋盘上，安放 8 个皇后，要求没有一个 皇后能够“吃掉”任何其它一个皇后，即任意两个皇后不能处于同一行，同一列或者同一条对角线上，求解有多少种摆法。  
高斯认为有 76 种方案。1854 年在柏林的象棋杂志上不同的作者发表了 40 种不同的解，后来有人用图论的方法得到结论，有 92 种摆法。  
本实验拓展了 N 皇后问题，即皇后个数由用户输入。  

### 1. 项目运行效果

- 建立棋盘

  棋盘为一个NXN的正方形二维数组，其中0代表棋盘格子上无皇后，1代表有皇后。N要求用户输入。  
  ```c++
  int size;
	cout << "现有NXN的棋盘，放入N个皇后，要求所有皇后不在同一行、列和斜线上！" << endl;
	cout << endl << "请输入皇后的个数：";
	cin >> size;
  ...
  auto chess = new Chess(size);
  ```
  这里输入的N（size）会有一定的要求，稍后我会在容错测试中提到这一点。  
  
- 摆放皇后

  摆放皇后由Queen类对象中的fillChess函数完成。  
  ```c++
  auto queen = new Queen(chess);
  ...
  queen->fillChess(0);
  ```
  这里，在建立Queen对象时，传入了Chess对象的指针，以让queen直到在哪个棋盘上进行摆放。  
  fillChess中的参数是指明在哪一行进行验证。  
  
- 运行截屏

  ![image](https://github.com/pancerZH/dataStructureProject/blob/master/Q4/image/run.PNG)
  （与题目演示中的运行结果仅有顺序上的不同）

### 2. 概述

- #### 项目要求及建议

  八皇后在棋盘上分布的各种可能的格局数目非常大，约等于 2 的 32 次方种，但是，可以将一些明显不满足问题要求的格局排除掉。  
  由于任意两个皇后不能同行，即每行只能放置 一个皇后，因此将第 i 个皇后放在第 i 行上，这样在放置第 i 个皇后时，只要考虑它与前 i-1 个皇后处于不同列和不同对角线位置上即可。  
  解决这个问题采用回溯法，首先将第一个皇后放置在第一行第一列，然后，依次在下一行上放置一个皇后，直到八个皇后全部放置安全。  
  在放置每个皇后时，都依次对每一列进行检测，首先检测放在第一列是否与已放置的皇后冲突，如不冲突，则将皇后放置在该列，否则，选择改行的下一列进行检测。  
  如整行的八列都冲突，则回到上一行，重新选择位置，依次类推。 
  
- #### 实现方法

  此题与上一题类似，都是使用回溯法。由于上一题使用了栈，那么这一次我将使用递归的方式完成任务。  
  
### 3. 类及类成员介绍
  
- #### Chess类  

  - ##### 成员变量
  |成员名称|属性|类型|描述|
  |--------|---|---|----|
  |size|public|int|描述棋盘尺寸|
  |field|public|int**|指向棋盘二维数组的指针|
  |totalNum|public|int|皇后在此大小棋盘上的摆法数量|
	
  - ##### 成员函数  
  |函数名称|返回值类型|描述|
  |--------|--------|----|
  |Chess|无|构造函数|
  |~Chess|无|析构函数，释放棋盘数组占用的空间|
  |checkPoint|bool|检查某一点是否可以摆放皇后|
  |showChess|void|打印棋盘及皇后摆放情况|
  
- #### Queen类
  
  - ##### 成员变量
  |成员名称|属性|类型|描述|
  |--------|---|---|----|
  |chess|private|Chess*|存放指向棋盘数组的指针|
  
  - ##### 成员函数
  |函数名称|返回值类型|描述|
  |-------|----------|---|
  |Queen|无|构造函数|
  |fillChess|void|递归函数，进行摆放皇后试探|
  
### 4. 核心代码解释  

  - 展示棋盘
  
  ```c++
  void Chess::showChess()
	{
		for (int i = 0;i < size;++i)
		{
			for (int j = 0;j < size;++j)
				cout << ((field[i][j]==1)?'X':'O') << ' ';
			cout << endl;
		}
		cout << endl;
	}
  ```
  展示棋盘的逻辑非常简单：逐个打印棋盘数组中的数字，如果数字是1，就打印'X'，它代表这个位置上有一个皇后；如果是0，就打印'O'，它代表这是一个空着的格子。  
  
  - 检查特定格子  
  
  我们在决定一个格子是否可以摆放皇后时，要检查四个方向：横、竖、斜（对应主对角线）和反斜（对应副对角线）。好在我们在进行递归时是按照行进行的，所以我们在进行正式的判断前，就可以断定在同一行是是不会有其他皇后的。于是我们可以用下面的代码解决检查的任务：
  ```c++
  bool Chess::checkPoint(const int x, const int y)
  {
    for (int i = 0;i < size;++i)//检查同一列上是否有皇后
      if (field[i][y] == 1)
        return false;

    for (int k = -(size - 1);k < size;++k)//检查主对角线上是否有皇后
    {
      if (x + k < 0 || y + k < 0)//还未抵达左上边界
        continue;
      if (x + k > size - 1 || y + k > size - 1)//已越过右下边界
        break;
      if (field[x + k][y + k] == 1)
        return false;
    }

    for (int k = -(size - 1);k < size;++k)//检查副对角线上是否有皇后
    {
      if (x + k<0 || y - k>size - 1)//还未抵达右上边界
        continue;
      if (x + k > size - 1 || y - k < 0)//已越过左下边界
        break;
      if (field[x + k][y - k] == 1)
        return false;
    }

    return true;
  }
  ```  
  可以看到我们检查了三个必不可少的方向。并且值得一提的是，在检查的时候千万小心越界的情况，所以必须在每组检查开头额外检查是不是越过了棋盘数组的边界。  
  
  - 摆放皇后
  
  checkPoint函数会告诉我们正在接受检查的点在当前情况下是否可以摆放皇后，所以我们可以这样设计递归函数：
  ```c++
  void Queen::fillChess(const int row)
  {
    if (row == chess->size)//皇后已经全部放置完毕
    {
      chess->showChess();
      ++(chess->totalNum);
      return;
    }

    for (int j = 0;j < chess->size;++j)
    {
      if (chess->checkPoint(row, j))
        chess->field[row][j] = 1;//将此格子放上皇后
      else//若此格子无法防止皇后，则考察相邻的下一个格子
        continue;

      fillChess(row + 1);//此行皇后放置好后，处理下一行
      chess->field[row][j] = 0;//此格子放置皇后的模拟已结束，回归无子状态，开始考察下一个格子
    }
  }
  ```
  这里，递归函数的出口被设置为“所有行都已经摆放好了皇后”。在这种情况下，我们打印棋盘并返回。当然，这不是结束所有的递归，而是回到了上一层递归，并继续寻找其它的解决方案，直到再也没有为止。  
  每当我们发现找到一组摆放方案时，我们都有打印棋盘，并且为总解法+1，这样我们在最后就可以很方便地得到最终的摆放方法数量了。  
