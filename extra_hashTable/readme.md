# 散列表实现
原理来自《数据结构与算法分析（C语言描述）》，实现时未按照所给例程操作，使用了其提供的数据

### 分离链接散列表
- 散列表自身长度为`size`，不参与存储。存储采用了`size`个单向链表完成。
- 为了便于进行删除操作，使用了表头。表头仅起到了定位作用，如果不进行删除操作，可以不使用表头，直接将表头部分也用作储存元素即可。
- 插入操作为插入到现有的链表的尾部，并考虑到了重复元素的情况。当插入元素与表中原有元素重复时，不进行插入。
- 构造散列表时，散列表自身请求了`size*sizeof(Node)`的连续空间，而链表部分为之后插入时自行申请。故而在析构时分两步析构：首先析构所有链表，然后析构散列表自身（一堆表头）

### 开放定址散列表
- 使用了Block的数组完成了操作，每个Block对象使用isEmpty判断是否已经插入了数据
- 实现了三种用于开放定址散列表的解决方案，分别为
	- 线性探测法
	- 平方探测法
	- 双散列
- 值得注意的是，除了线性探测法，其余的两种方法都不能实行一般意义上的`删除`操作（或者说只能进行`懒惰删除`）。所以并未实现对开放定址散列表的删除操作。

### 再散列表
- 注意，在Rehashchain类中，`capacity`表示表的容量，`size`表示表中元素数量。这一点与之前的类有所不同。
- 当装填因子lambda大于某个值（这里是0.7）时，进行再散列。
- 再散列后表的大小为不小于旧表大小的2倍的最小素数。
- 在未进行再散列时遇到冲突（此时lambda小于等于0.7），使用线性探测法解决冲突。
- Rehashchain类未实现元素的移除，但这是极容易的。
