#include <iostream>
#include <ctime>

using namespace std;

class Sort {
	/*一律按照从小到大的顺序排序*/
public:
	Sort(const int);
	void copyNumGroup();//将生成的数组拷贝到操作数组中
	void swap(int&, int&);//交换提供的两个元素
	bool check();//检查排序是否正确
	void show();//打印排序后的数组
	void bubble();//冒泡排序
	void selection();//选择排序
	void insertion();//直接插入排序
	void shell();//希尔排序
	void quick();//快速排序
	void quickSort(const int, const int, int&);//快速排序的子函数，用于递归
	void heap();//堆排序
	void percDown(const int, const int, int&);//堆排序的子函数，用于空穴下滤
private:
	int size;
	int* numGroup;
	int* copyGroup;
};

Sort::Sort(const int size)
	:size(size)
{
	numGroup = new int[size];
	copyGroup = new int[size];
	if (numGroup == NULL || copyGroup == NULL)
	{
		cerr << "内存空间不足！" << endl;
		exit(1);
	}

	for (int i = 0;i < size;++i)
		*(numGroup + i) = rand();
}

void Sort::copyNumGroup()
{
	for (int i = 0;i < size;++i)
		*(copyGroup + i) = *(numGroup + i);
}

void Sort::swap(int& i, int& j)
{
	int changeNum = i;
	i = j;
	j = changeNum;
}

bool Sort::check()
{
	for (int i = 0;i < size - 1;++i)
	{
		if (copyGroup[i] > copyGroup[i + 1])//发现未排好序的数字
		{
			cout << "排序失败！" << endl;
			return false;
		}
	}
	cout << "排序成功！" << endl;
	return true;
}

void Sort::show()
{
	for (int i = 0;i < size;++i)
		cout << copyGroup[i] << ' ';
	cout << endl;
}

void Sort::bubble()
{
	copyNumGroup();//将数据复制到操作数组中
	int total = 0;
	clock_t start, finish;
	
	start = clock();
	for (int i = 0;i < size - 1;++i)
	{
		for (int j = 0;j < size - 1 - i;++j)
		{
			if (copyGroup[j] > copyGroup[j + 1])
			{
				swap(copyGroup[j], copyGroup[j + 1]);
				++total;
			}
		}
	}
	finish = clock();

	cout << "冒泡排序所用时间：\t" << float(finish - start) / CLOCKS_PER_SEC << endl;
	cout << "冒泡排序交换次数：\t" << total << endl;
	check();
	//show();
}

void Sort::selection()
{
	copyNumGroup();//将数据复制到操作数组中
	int total = 0;
	clock_t start, finish;

	start = clock();
	for (int i = 0;i < size - 1;++i)
	{
		int min = copyGroup[size - 1];
		int position = size - 1;
		for (int j = i;j < size - 1;++j)
		{
			if (copyGroup[j] < min)
			{
				min = copyGroup[j];
				position = j;
			}
		}

		swap(copyGroup[i], copyGroup[position]);
		++total;
	}
	finish = clock();

	cout << "选择排序所用时间：\t" << float(finish - start) / CLOCKS_PER_SEC << endl;
	cout << "选择排序交换次数：\t" << total << endl;
	check();
	//show();
}

void Sort::insertion()
{
	copyNumGroup();//将数据复制到操作数组中
	int total = 0;
	clock_t start, finish;

	start = clock();
	for (int i = 0;i < size;++i)
	{
		/*下面的每次循环都要检测第i个元素是否可以放在第j-1个元素之前*/
		/*由于前i-1个元素已经排好序，所以一旦发现无法继续向前移动，则停止循环*/
		for (int j = i;j > 0 && copyGroup[j - 1] > copyGroup[j];--j)
		{
			swap(copyGroup[j], copyGroup[j - 1]);//每次将第i个元素向前移动
			++total;
		}
	}
	finish = clock();

	cout << "直接插入排序所用时间：\t" << float(finish - start) / CLOCKS_PER_SEC << endl;
	cout << "直接插入排序交换次数：\t" << total << endl;
	check();
}

void Sort::shell()
{
	copyNumGroup();//将数据复制到操作数组中
	int total = 0;
	clock_t start, finish;

	int k, product = 1;
	for (k = 0;product * 2 - 1 <= size;++k)//找到Hibbard增量上界
		product *= 2;

	start = clock();
	for (int increment = product - 1;increment > 0;product /= 2, increment = product - 1)
	{
		/*希尔排序内部使用插入排序，并且可以保证前i个数字是increment-排序的*/
		for (int i = increment;i < size;++i)
		{
			for (int j = i;j >= increment;j -= increment)
			{
				if (copyGroup[j] < copyGroup[j - increment])
				{
					swap(copyGroup[j], copyGroup[j - increment]);
					++total;
				}
				else//已经排好序了
					break;
			}
		}
	}
	finish = clock();

	cout << "希尔排序所用时间：\t" << float(finish - start) / CLOCKS_PER_SEC << endl;
	cout << "希尔排序交换次数：\t" << total << endl;
	check();
}

void Sort::quick()
{
	copyNumGroup();//将数据复制到操作数组中
	int total = 0;
	clock_t start, finish;

	start = clock();
	quickSort(0, size - 1, total);
	finish = clock();

	cout << "快速排序所用时间：\t" << float(finish - start) / CLOCKS_PER_SEC << endl;
	cout << "快速排序交换次数：\t" << total << endl;
	check();
}

void Sort::quickSort(const int left, const int right, int& total)
{
	int i = left, j = right;//分别指向数组的头尾
	if (left > right)
		return;

	int key = copyGroup[left];//找到基准元
	while (i != j)
	{
		while (j > i&&key <= copyGroup[j])
			--j;//找到右侧第一个小于基准元的数
		while (i < j&&key >= copyGroup[i])
			++i;//找到左侧第一个大于基准元的数
		if (i < j)//如果两数未重叠，则交换它们的值
		{
			swap(copyGroup[i], copyGroup[j]);
			++total;
		}
	}
	swap(copyGroup[i], copyGroup[left]);//基准元归位
	++total;

	quickSort(left, i - 1, total);//继续处理左半部分
	quickSort(i + 1, right, total);//继续处理右半部分
}

void Sort::heap()
{
	copyNumGroup();//将数据复制到操作数组中
	int total = 0;
	clock_t start, finish;

	start = clock();
	for (int i = size / 2;i >= 0;--i)//建堆,最大的元素位于根部
		percDown(i, size, total);
	for (int i = size - 1;i > 0;--i)
	{
		/*将堆中最大元素排在排序区头部，排序区整体上为由小到大*/
		swap(copyGroup[i], copyGroup[0]);
		++total;
		percDown(0, i, total);
	}
	finish = clock();

	cout << "堆排序所用时间：\t" << float(finish - start) / CLOCKS_PER_SEC << endl;
	cout << "堆排序交换次数：\t" << total << endl;
	check();
}

void Sort::percDown(const int downIndex, const int endIndex, int& total)
{
	int childIndex;//它将指向两个儿子中较大的那一个
	for (int i = downIndex;2 * i + 1 < endIndex;i = childIndex)
	{
		childIndex = 2 * i + 1;//现在指示的是左儿子的坐标
		/*存在的前提下，若右儿子大于左儿子，则将childIndex改为左儿子坐标*/
		if (childIndex != endIndex - 1 && copyGroup[childIndex] < copyGroup[childIndex + 1])
			++childIndex;
		if (copyGroup[i] < copyGroup[childIndex])
		{
			swap(copyGroup[i], copyGroup[childIndex]);//元素下滤
			++total;
		}
		else//下滤的元素找到了合适的位置；恢复了堆序性
			break;
	}
}